https://www.youtube.com/watch?v=Ps8HDIAyPD0&list=PLuHgQVnccGMDeMJsGq2O-55Ymtx0IdKWf
도커 입문수업 #1~8
(유튜브:생활코딩)
	- 웹 기준으로 설명해줌.
	- 6편에서 다른 에디터를 사용하라고 하는데 저희는(배종현 대리 + 최준하 사원) vscode(또는 visual studio) 사용할 예정 


docker desktop 설치 후 위 상단에 hub검색에서 ubuntu 를 설치(pull)한 후 images에서 확인 가능.



************터미널에서 도커 c++ 빌드 및 실행 (*다른 언어도 응용해서 빌드 가능함) *******************

-----------편의상 겅로를 C:\Users\user\Downloads 로 하겠습니다. (*모두 이 경로 안에 있다고 가정)---------


1. 우선 c++파일을 만든 후 (이 코드를 FileName.cpp라는 이름의 파일로 저장합니다) 


2. 도커파일을 만듭니다 (텍스트파일에서 명령어들을 아래와 같이 적은 뒤에 확장자를 .dockerfile 로 지정하면 됩니다.) ( test(c++).dockerfile )

# 베이스 이미지로 Ubuntu를 선택
FROM ubuntu:latest

# 필요한 패키지 설치( 최신버전으로 업데이트 && g++ 컴파일러 설치) - 필수
RUN apt-get update && apt-get install -y build-essential

# 작업 디렉토리 설정 - 컨테이너 안에서의 경로입니다.
WORKDIR /app

# 만든 c++파일을 컨테이너안에 복붙 - dockerfile이랑 같은 경로에 있어야함
COPY FileName.cpp /app/

# C++ 프로그램 컴파일
RUN g++ -o HelloWorld FileName.cpp

# 컨테이너 실행 시 HelloWorld 실행 파일 실행
CMD ["./HelloWorld"]

*** 컴파일러를 계속 설치하면 이미지의 용량이 낭비가 되니 아래와 같이 수정 ****

# 한번 빌드하고 그것을 복붙
FROM ubuntu:latest as builder
RUN apt-get update && apt-get install -y build-essential
WORKDIR /app
COPY FileName.cpp .
RUN g++ -o HelloWorld FileName.cpp

FROM ubuntu:latest
WORKDIR /app

COPY --from=builder /app/HelloWorld .
CMD ["./HelloWorld"]


3. 터미널에서 이미지 빌드
cd c:\Users\user\Downloads 로 변경 후

docker build -f "test(c++).dockerfile" -t mytestapp .
-f 옵션은 Dockerfile의 이름과 경로를 지정합니다.
-t 옵션은 생성될 이미지의 이름을 설정합니다.
마지막의 .은 현재 디렉토리를 Docker 빌드 컨텍스트로 사용하겠다는 의미입니다.

빌드하면 docker desktop에서 볼 수 있습니다.
한번 빌드하면 c:\Users\user\Downloads 안에있던 FileName.cpp 와 도크파일은 지워도 됨.

4. 실행
터미널 -> docker run mytestapp.
Hello Would!~

docker desktop -> 실행 아이콘 누르면 됨
[LOGS] 2024-04-29 09:16:32 Hello Would!~


----------------------------------------------------------------------
-----컨테이너간 통신

도커에서 네트워크를 생성하고 공유할수있음.

docker network create my_network
docker run -d --name mytest_server_instance --network my_network -p <외부포트>:<컨테이너포트> mytest_server
docker run -d --name mytest_client_instance --network my_network mytest_client

run은 생성후 실행이라 처음에만 쓸수있음 그후엔 start나 restart로 실행

run -it 를 하면 터미널에 입력 가능
start -ai 를 하면 터미널에 입력 가능


--------------------------------------------------------------------------
---------도커 볼륨(컨테이너간 공유 파일)

--rm은 임시(한번 사용하고 지워짐)
C:\Users\user\Downloads>docker run --rm -it -v C:/Users/user/Downloads/test_odm_call:/photos busybox sh
/ # cd /photos
/photos # ls
100_0003_0001.JPG  100_0003_0002.JPG  100_0003_0003.JPG

docker run -it --name odm_call -v C:/Users/user/Downloads/test_odm_call:/photos -v output_v:/output odm_call_app
호스트의 경로:컨테이너의 경로(없으면 만듬) & 볼륨의 이름: 컨테이너 경로 image의 이름


docker run --rm -v dems_jpgs_volume:/mydata -v D:/DEM_2021y_5m(img):/local busybox sh -c "cp /local/* /mydata/"


---------쿠버네티스 사용법( 선택 사항 )-----------

1. Docker 이미지를 Docker Hub에 푸시
터미널에
->docker login
->docker tag mytestapp username/mytestapp
->docker push username/mytestapp


2. 쿠버네티스 yaml파일 생성 (아래처럼 쓰면 됨 - deployment.yaml)
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mytestapp-deployment
spec:
  replicas: 3
  selector:
    matchLabels:
      app: mytestapp
  template:
    metadata:
      labels:
        app: mytestapp
    spec:
      containers:
      - name: mytestapp
        image: username/mytestapp
        ports:
        - containerPort: 8080

3. kubectl을 사용하여 Deployment를 쿠버네티스 클러스터에 적용
터미널 -> kubectl apply -f deployment.yaml


4. service.yaml 파일을 생성
apiVersion: v1
kind: Service
metadata:
  name: mytestapp-service
spec:
  type: NodePort
  ports:
    - port: 8080
      targetPort: 8080
      nodePort: 30001
  selector:
    app: mytestapp


5. 서비스 적용
터미널 ->
kubectl apply -f service.yaml
kubectl get pods
kubectl get service


